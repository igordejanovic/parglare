<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Igor Dejanović" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Disambiguation - parglare</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../style.css" rel="stylesheet" />
        <link href="../css/version-select.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Disambiguation";
        var mkdocs_page_input_path = "disambiguation.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-68681917-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', "UA-68681917-1");
      </script>
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> parglare
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">User Guide</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../getting_started/">Getting started</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../grammar_language/">Grammar language</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../grammar/">Grammar class</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../parser/">Parser</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../actions/">Actions</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../common/">Common API</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../recognizers/">Recognizers</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../grammar_modularization/">Modularization</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../lr_parsing/">LR parsing and conflicts</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Disambiguation</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#static-disambiguation-filters">Static disambiguation filters</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#priority">priority</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#associativity">associativity</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#nops-and-nopse">nops and nopse</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#prefer">prefer</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#dynamic-disambiguation-filter">Dynamic disambiguation filter</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#disambiguation-of-a-glr-forest">Disambiguation of a GLR Forest</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#lexical-ambiguities">Lexical ambiguities</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#custom-token-recognition-and-lexical-disambiguation">Custom token recognition and lexical disambiguation</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../parse_forest_trees/">Parse forest/trees</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../handling_errors/">Handling errors</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../pglr/">pglr command</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../debugging/">Debugging</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Release Notes</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../release_notes/release_0_15/">0.15</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../release_notes/release_0_14/">0.14</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">About</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../about/CONTRIBUTING/">Contributing</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../about/LICENSE/">License</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">parglare</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">User Guide</li>
      <li class="breadcrumb-item active">Disambiguation</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/igordejanovic/parglare/edit/master/docs/disambiguation.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="disambiguation">Disambiguation<a class="headerlink" href="#disambiguation" title="Permanent link">&para;</a></h1>
<p>At each step LR parser has to decide which operation to execute: SHIFT (to
consume the next token) or REDUCE (to reduce what it saw previously to some
higher level concept).
See <a href="../lr_parsing/">section on LR parsing and conflicts</a>.</p>
<p>Defining language by CFG alone often leads to ambiguous languages. Sometimes
this is what we want, i.e. our inputs indeed have multiple interpretation and we
want all of them. This is usually true for natural languages. But when we deal
with computer languages we want to avoid ambiguity as there should be only one
interpretation for each valid input. We want to define unambiguous language.</p>
<p>To constrain our grammar and make it define unambiguous language we use so
called <em>disambiguation filters</em>. These filters are in charge of choosing the
right interpretation/tree when there is ambiguity in the grammar.</p>
<p>Even in the simple expression grammar there is ambiguity. For example,
<code>2 + 3 * 4</code> expression — in case we know nothing about priorities of arithmetic
operations — can be interpreted in two different ways: <code>(2 + 3) * 4</code> and
<code>2 + (3 * 4)</code>. Without priorities we would be obliged to use parentheses
everywhere to specify the right interpretation.</p>
<p>Ambiguity is a one source of conflicts in the LR grammars. The other is limited
lookahead. Whatever is the source of conflicts <code>GLRParser</code> can cope with it. In
case of ambiguity the parser will return all interpretations possible. In case
of a limited lookahead the parser will investigate all possible paths and
resolve to the correct interpretation further down the input stream.</p>
<p>If our grammar is ambiguous and our language is not that means that we need to
constrain our grammar using disambiguation filters to better describe our
language. Ideally, we strive for a grammar that describe all valid sentences in
our language with a single interpretation for each of them and nothing more.</p>
<h2 id="static-disambiguation-filters">Static disambiguation filters<a class="headerlink" href="#static-disambiguation-filters" title="Permanent link">&para;</a></h2>
<p>Static disambiguation filters are given in the grammar at the end of the
production using <code>{}</code> syntax. There is also
a <a href="#dynamic-disambiguation-filter">dynamic disambiguation filter</a> that is most
powerful and is specified as a Python function.</p>
<h3 id="priority">priority<a class="headerlink" href="#priority" title="Permanent link">&para;</a></h3>
<p>Priority is probably the simplest form of disambiguation. It is also the
strongest in parglare as it's first checked. It is given as a numeric value
where the default is 10. When the parser can't decide what operation to use it
will favor the one associated with the production with a higher priority.</p>
<p>For example:</p>
<pre><code>E: E &quot;*&quot; E {2};
E: E &quot;+&quot; E {1};
</code></pre>
<p>This gives priority of <code>2</code> to the production <code>E "*" E</code> and <code>1</code> to the production
<code>E "+" E</code>. When parglare needs to decide, e.g. between shifting <code>+</code> or reducing
<code>*</code> it saw, it will choose reduce as the multiplication production has higher
priority.</p>
<p>Priority can also be given to terminal productions.</p>
<h3 id="associativity">associativity<a class="headerlink" href="#associativity" title="Permanent link">&para;</a></h3>
<p>Associativity is used for disambiguation between productions of the same
priority. In the grammar fragment above we still have ambiguity for expression:</p>
<pre><code>2 + 3 + 5
</code></pre>
<p>There are two interpretations <code>(2 + 3) + 5</code> and <code>2 + (3 + 5)</code>. Of course, with
arithmetic <code>+</code> operation the result will be the same but that's not true for
each operation. Anyway, parse trees will be different so some choice has to be
made.</p>
<p>In this situation associativity is used. Both <code>+</code> and <code>*</code> in arithmetic are
left associative (i.e. the operation is evaluated from left to right).</p>
<pre><code>E: E &quot;*&quot; E {2, left};
E: E &quot;+&quot; E {1, left};
</code></pre>
<p>Now, the expression above is not ambiguous anymore. It is interpreted as <code>(2 +
3) + 5</code>.</p>
<p>The associativity given in the grammar is either <code>left</code> or <code>right</code>. Default is
no associativity, i.e. associativity is not used for disambiguation decision.</p>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Alternatively, you can use keyword <code>shift</code> instead of <code>right</code> and <code>reduce</code>
instead of <code>left</code>.</p>
</div>
<h3 id="nops-and-nopse"><code>nops</code> and <code>nopse</code><a class="headerlink" href="#nops-and-nopse" title="Permanent link">&para;</a></h3>
<p>These two are not actual filters but markers used to disable
<a href="../parser/#prefer_shifts"><code>prefer_shifts</code></a> (<code>nops</code>) and
<a href="../parser/#prefer_shifts_over_empty"><code>prefer_shifts_over_empty</code></a> (<code>nopse</code>) set
globally during parser construction on a production level. Productions using
these markers are not influenced by global parser setting meaning that table
construction will not eliminate possible reductions on these productions. Using
these markers have sense only for GLR parsing as the LR deterministic parser
can't be constructed anyway in case of conflicts.</p>
<p>For example:</p>
<pre><code>Statements: Statements1 {nops}
          | EMPTY;
</code></pre>
<h3 id="prefer">prefer<a class="headerlink" href="#prefer" title="Permanent link">&para;</a></h3>
<p>This disambiguation filter is applicable to terminal productions only. It will
be used to choose the right recognizer/terminal in case
of <a href="#lexical-ambiguities">lexical ambiguity</a>.</p>
<p>For example:</p>
<pre><code>INT: /[-+]?[0-9]+\b/ {prefer};
FLOAT: /[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\b/;
</code></pre>
<p>If in the grammar we have a possibility that both recognizers are tried, both
will succeed for input <code>23</code>, but we want <code>INT</code> to be chosen in this case.</p>
<h2 id="dynamic-disambiguation-filter">Dynamic disambiguation filter<a class="headerlink" href="#dynamic-disambiguation-filter" title="Permanent link">&para;</a></h2>
<p>All previously described filters are of static nature, i.e. they are compiled
during LR table calculation (by removing erroneous automata transitions) and
they don't depend on the parsed input.</p>
<p>There are sometimes situations when parsing decision depends on the input.</p>
<p>For example, lets say that we need to parse arithmetic expression but our
operation priority increase for operations that are introduced later in the
input.</p>
<pre><code>1 + 2 * 3 - 4 + 5
</code></pre>
<p>Should be parsed as:</p>
<pre><code>((1 + (2 * (3 - 4))) + 5)
</code></pre>
<p>While</p>
<pre><code>1 - 2 + 3 * 4 + 5
</code></pre>
<p>should be parsed as:</p>
<pre><code>(1 - ((2 + (3 * 4)) + 5))
</code></pre>
<p>As you can see, operations that appears later in the input are of higher priority.</p>
<p>In parglare you can implement this dynamic behavior in two steps:</p>
<p>First, mark productions in your grammar by <code>dynamic</code> rule:</p>
<pre><code>E: E op_sum E {dynamic}
 | E op_mul E {dynamic}
 | /\d+/;
op_sum: '+' {dynamic};
op_mul: '*' {dynamic};
</code></pre>
<p>This tells parglare that those production are candidates for dynamic ambiguity
resolution.</p>
<p>Second step is to register a predicate function, during parser construction,
that will be used for resolution. This function operates as a filter for
actions. It receives the parsing context for the action, the LR automata states
between whom the transition is about to occur, and the sub-results in the case
of a reduction. The function should return <code>True</code> if the transition is allowed
or <code>False</code> otherwise. This function sometimes need to maintain some kind of
state. To initialize its state at the beginning it is called with <code>None</code> as
parameters.</p>
<pre><code>parser = Parser(grammar, dynamic_filter=custom_disambiguation_filter)
</code></pre>
<p>Where resolution function is of the following form:</p>
<pre><code class="language-python">def custom_disambiguation_filter(context, from_state, to_state, action,
                                 production, subresults):
    &quot;&quot;&quot;
    Make first operation that appears in the input as lower priority.
    This demonstrates how priority rule can change dynamically depending
    on the input.
    &quot;&quot;&quot;
    global operations

    # At the start of parsing this function is called with actions set to None
    # to give a chance for the strategy to initialize.
    if action is None:
        operations = []
        return

    if action is SHIFT:
        operation = context.token.symbol
    else:
        operation = context.token_ahead.symbol

    actions = from_state.actions[operation]
    if operation not in operations and operation.name != 'STOP':
        operations.append(operation)

    if action is SHIFT:
        shifts = [a for a in actions if a.action is SHIFT]
        if not shifts:
            return False

        reductions = [a for a in actions if a.action is REDUCE]
        if not reductions:
            return True

        red_op = reductions[0].prod.rhs[1]
        return operations.index(operation) &gt; operations.index(red_op)

    elif action is REDUCE:

        # Current reduction operation
        red_op = production.rhs[1]

        # If operation ahead is STOP or is of less or equal priority -&gt; reduce.
        return ((operation not in operations)
                or (operations.index(operation)
                    &lt;= operations.index(red_op)))
</code></pre>
<p>This function is a predicate that will be called for each action for productions
marked with <code>dynamic</code> (SHIFT action for dynamic terminal production and REDUCE
action for dynamic non-terminal productions). You are provided with enough
information to make a custom decision whether to perform or reject the
operation.</p>
<p>Parameters are:</p>
<ul>
<li>
<p><strong>context</strong> - <a href="../common/#the-context-object">the parsing context object</a>.</p>
</li>
<li>
<p><strong>from_state/to_state</strong> -- <code>LRState</code> instances for the transition,</p>
</li>
<li>
<p><strong>action</strong> - either SHIFT or REDUCE constant from <code>parglare</code> module,</p>
</li>
<li>
<p><strong>production</strong> - a production used for the REDUCE operation. Valid only if
  action is REDUCE.</p>
</li>
<li>
<p><strong>subresults (list)</strong> - a sub-results for the reduction. Valid only for
  REDUCE. The length of this list is equal to <code>len(production.rhs)</code>.</p>
</li>
</ul>
<p>For details see <a href="https://github.com/igordejanovic/parglare/blob/master/tests/func/parsing/test_dynamic_disambiguation_filters.py">test_dynamic_disambiguation_filters.py</a>.</p>
<h2 id="disambiguation-of-a-glr-forest">Disambiguation of a GLR Forest<a class="headerlink" href="#disambiguation-of-a-glr-forest" title="Permanent link">&para;</a></h2>
<p>For GLR forests there is an additional option for a disambiguation. The GLR
forest has a <code>disambiguate</code> method that accepts a callable of the following
signature:</p>
<pre><code>    def disam_callable(parent):
</code></pre>
<p>It accepts the GLR GSS <code>Parent</code> object which has a list of possibilities and the
callable should remove all invalid possibilities from the list. The callable is
called bottom-up for all <code>Parent</code> object which have more than one possibility.</p>
<p>For a full example with comments see <a href="https://github.com/igordejanovic/parglare/blob/master/tests/func/parsing/test_glr_forest_disambiguation.py">this
test</a>.</p>
<h2 id="lexical-ambiguities">Lexical ambiguities<a class="headerlink" href="#lexical-ambiguities" title="Permanent link">&para;</a></h2>
<p>There is another source of ambiguities.</p>
<p>Parglare uses integrated scanner, thus tokens are determined on the fly. This
gives greater lexical disambiguation power but lexical ambiguities might arise
nevertheless. Lexical ambiguity is a situation when at some place in the input
more than one recognizer match successfully.</p>
<p>For example, if in the input we have <code>3.4</code> and we expect at this place either an
integer or a float. Both of these recognizer can match the input. The integer
recognizer would match <code>3</code> while the float recognizer would match <code>3.4</code>. What
should we use?</p>
<p>parglare has lexical disambiguation strategy that will use priorities first. If
this fails (i.e. all terminals have the same priority) we continue with implicit
disambiguation strategy as follows:</p>
<ol>
<li>String recognizers are preferred over regexes (i.e. the most specific match).</li>
<li>If we still have multiple matches use longest-match strategy.</li>
<li>If more recognizers still match use <code>prefer</code> rule if given.</li>
<li>If all else fails raise an exception. In case of GLR, ambiguity will be
   handled by parser forking, i.e. you will end up with all solutions/trees.</li>
</ol>
<p>Thus, in terminal definition rules we can use priorities to favor some of the
recognizers, or we can use <code>prefer</code> to favor recognizer if there are multiple
matches of the same length.</p>
<p>For example:</p>
<pre><code class="language-nohighlight">number: /\d+/ {15};
</code></pre>
<p>or:</p>
<pre><code class="language-nohighlight">number: /\d+/ {prefer};
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Implicit lexical disambiguation is controlled by <code>lexical_disambiguation</code>
parameter passed to <code>Parser</code>/<code>GLRParser</code> constructor. By default, <code>Parser</code>
uses implict disambiguation while <code>GLRParser</code> doesn't.</p>
</div>
<p>In addition, you can also specify that the terminal takes part in dynamic
disambiguation:</p>
<pre><code class="language-nohighlight">number: /\d+/ {dynamic};
</code></pre>
<h2 id="custom-token-recognition-and-lexical-disambiguation">Custom token recognition and lexical disambiguation<a class="headerlink" href="#custom-token-recognition-and-lexical-disambiguation" title="Permanent link">&para;</a></h2>
<p>In the previous section a built-in parglare lexical disambiguation strategy is
explained. There are use-cases when this strategy is not sufficient. For
example, if we want to do fuzzy match of tokens and choose the most similar
token at the position.</p>
<p>parglare solves this problem by enabling you to implement a custom token
recognition by registering a callable during parser instantiation that will,
during parsing, get all the symbols expected at the current location and return
a list of tokens (instances of <a href="../parser/#token-class"><code>Token</code> class</a>) or <code>None</code>/
empty list if no symbol is found at the location.</p>
<p>This callable is registered during parser instantiation as the parameter
<code>custom_token_recognition</code>.</p>
<pre><code>parser = Parser(
    grammar, custom_token_recognition=custom_token_recognition)
</code></pre>
<p>The callable accepts:</p>
<ul>
<li>
<p><strong>context</strong> - <a href="../common/#the-context-object">the parsing context object</a>.</p>
</li>
<li>
<p><strong>get_tokens</strong> - a callable used to get the tokens recognized using the
  default strategy. Called without parameters. Custom disambiguation might
  decide to return this list if no change is necessary, reduce the list, or
  extend it with new tokens. See the example below how to return list with a
  token only if the default recognition doesn't succeed.</p>
</li>
</ul>
<p><strong>Returns:</strong> a list of <a href="../parser/#token-class"><code>Token</code> class instances</a> or
<code>None</code>/empty list if no token is found.</p>
<p>To instantiate <code>Token</code> pass in the symbol and the value of the token. Value of
the token is usually a sub-string of the input string.</p>
<p>In the following test <code>Bar</code> and <code>Baz</code> non-terminals are fuzzy matched. The
non-terminal with the higher score wins but only if the score is above 0.7.</p>
<pre><code class="language-python">grammar = &quot;&quot;&quot;
S: Element+;
Element: Bar | Baz | Number;

terminals
Bar: /Bar. \d+/;
Baz: /Baz. \d+/;
Number: /\d+/;
&quot;&quot;&quot;

g = Grammar.from_string(grammar)
grammar = [g]

def custom_token_recognition(context, get_tokens):
    &quot;&quot;&quot;
    Custom token recognition should return a single token that is
    recognized at the given place in the input string.
    &quot;&quot;&quot;
    # Call default token recognition.
    tokens = get_tokens()

    if tokens:
        # If default recognition succeeds use the result.
        return tokens
    else:
        # If no tokens are found do the fuzzy match.
        matchers = [
            lambda x: difflib.SequenceMatcher(None, 'bar.', x.lower()),
            lambda x: difflib.SequenceMatcher(None, 'baz.', x.lower())
        ]
        symbols = [
            grammar[0].get_terminal('Bar'),
            grammar[0].get_terminal('Baz'),
        ]
        # Try to do fuzzy match at the position
        elem = context.input_str[context.position:context.position+4]
        elem_num = context.input_str[context.position:]
        number_matcher = re.compile('[^\d]*(\d+)')
        number_match = number_matcher.match(elem_num)
        ratios = []
        for matcher in matchers:
            ratios.append(matcher(elem).ratio())

        max_ratio_index = ratios.index(max(ratios))
        if ratios[max_ratio_index] &gt; 0.7 and number_match.group(1):
            return [Token(symbols[max_ratio_index], number_match.group())]


parser = Parser(
    g, custom_token_recognition=custom_token_recognition)


# Bar and Baz will be recognized by a fuzzy match
result = parser.parse('bar. 56 Baz 12')
assert result == ['bar. 56', 'Baz 12']

result = parser.parse('Buz. 34 bar 56')
assert result == ['Buz. 34', 'bar 56']

result = parser.parse('Ba. 34 baz 56')
assert result == ['Ba. 34', 'baz 56']

# But if Bar/Baz are too different from the correct pattern
# we get ParseError. In this case `bza` score is below 0.7
# for both Bar and Baz symbols.
with pytest.raises(ParseError):
    parser.parse('Bar. 34 bza 56')
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code>custom_token_recognition</code> can be used to implement custom lexical
disambiguation by calling <code>get_tokens</code> and then reducing returned list to a
list with a single result.</p>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>See the end of <a href="../parse_forest_trees/">the parse trees section</a> for a tip on how to
investigate ambiguities in GLR parsing.</p>
</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../lr_parsing/" class="btn btn-neutral float-left" title="LR parsing and conflicts"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../parse_forest_trees/" class="btn btn-neutral float-right" title="Parse forest/trees">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright &copy; <a href="http://igordejanovic.net/">Igor Dejanović</a>.</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/igordejanovic/parglare" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../lr_parsing/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../parse_forest_trees/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
      <script src="../js/version-select.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
