* Getting started
  :PROPERTIES:
  :CUSTOM_ID: getting-started
  :END:
The first thing to do is to write your language grammar using the
[[./grammar_language.md][parglare grammar language]]. You write the
grammar either as a Python string in your source code or as a separate
file. In case you are writing a grammar of a complex language I would
suggest the separate file approach. Although not mandatory, the
convention is that parglare grammar files have =.pg= extension.

The next step is to create the instance of the =Grammar= class. This is
achieved by importing the =Grammar= class and calling either =from_file=
or =from_str= methods supplying the file name for the former and the
Python string for the later call.

#+begin_src python
  from parglare import Grammar

  file_name = .....
  grammar = Grammar.from_file(file_name)
#+end_src

If there is no errors in the grammar you now have the grammar instance.
For more information see the [[./grammar.md][section about =Grammar=
class]].

!!! tip

#+begin_example
  There is also a handy [pglr command line tool](./pglr.md) that can be
  used for grammar checking, visualization and debugging.
#+end_example

The next step is to create an instance of the parser. There are two
options. If you want to use LR parser instantiate =Parser= class. For
GLR instantiate =GLRParser= class.

#+begin_src python
  from parglare import Parser
  parser = Parser(grammar)
#+end_src

or

#+begin_src python
  from parglare import GLRParser
  parser = GLRParser(grammar)
#+end_src

You can provide additional [[./parser.md][parser parameters]] during
instantiation.

!!! note

#+begin_example
  LR parser is faster as the GLR machinery brings a significant overhead. So,
  the general advice is to stick to the LR parsing until you are sure that you
  need additional power of GLR, i.e. either you need more than one token of
  lookahead or your language is inherently ambiguous. pglr tool will help you in
  investigating why you have LR conflicts in your grammar and there are some
  nice [disambiguation features](./lr_parsing.md#resolving-conflicts) in parglare
  that will help you resolve some of those conflicts.
#+end_example

Now parse your input calling =parse= method on the parser instance.

#+begin_src python
  result = parser.parse(input_str)
#+end_src

Depending on whether you have configured [[./actions.md][actions]] and
what parameters you used for parser instance you will get either:

- a nested lists if no actions are used,
- a parse tree if [[./parser.md#build_tree][=build_tree= parser param]]
  is set to =True=,
- some other representation of your input if custom actions are used.

In case of the GLR parser you will get a list of all possible results
(a.k.a. /the parse forest/).

** Where to go next?
   :PROPERTIES:
   :CUSTOM_ID: where-to-go-next
   :END:
You can investigate various topics in the docs. The
[[https://github.com/igordejanovic/parglare/tree/master/examples][examples]]
and the
[[https://github.com/igordejanovic/parglare/tree/master/tests/func][tests]]
are also a good source of information.
